<!DOCTYPE HTML>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>Summary</title>
        <link rel="stylesheet" href="summary.css">
    </head>
    <body>
        <h1>オブジェクト指向</h1>
        <h2>オブジェクト指向で覚えるべき4つのキーワード</h2>
        <ul>
            <li>クラス</li>
            <li>メソッド</li>
            <li>プロパティ</li>
            <li>インスタンス</li>
        </ul>
        <p>オブジェクト指向とはクラスと呼ばれる概念で構成される考え方</p>
        <h2>クラス</h2>
        <p>クラスとは共通して持っている必要最低限の機能や特徴をまとめましょう　という考え方</p>
        <p>共通して持つ特徴　（名前、身長、性別など）<br>共通して持つ機能（歩く、食べる、寝るなど）</p>
        <p>共通して持つ特徴の事をメンバ変数（プロパティ、インスタンス変数）という<br>また、共通して持つ機能の事をメンバ関数（メソッド）という</p>
        <h2>メソッド</h2>
        <p>クラスの中で定義された関数のことをメソッドという（作ったモノ（オブジェクト）に対する命令文）</p>
        <p>例</p>
        <p>public  function walk(){}<br>public  function eat(){}<br>public  function sleep(){}</p>
        <p>メソッドは関数なので{}で何かしらの行動を定義できる</p>
        <p>public → クラスの外から関数を呼び出せる</p>
        <h2>プロパティ</h2>
        <p>クラスの中で定義された変数のことをプロパティという</p>
        <p>例</p>
        <p>private $name;<br>private $height;<br>private $gender;</p>
        <p>メソッドとは対照的にこれはクラス内でしか操作できないので外側からはこの変数には触ることができない</p>
        <h2>インスタンス</h2>
        <p>クラスを利用して、実際にオブジェクトを作成したもの<br>インスタンスを作成することで、具体的にPHPで様々な作業をオブジェクトに任せられるようになる</p>
        <p>コンストラクタ...   インスタンスが作成された時に一番最初に呼び出される関数</p>
        <p>function__construct(){}　定義する</p>
        <p>例</p>
        <p>function__construct($name, $height, $gender) {<br>$this->name = $name;<br>$this->height = $height;<br>$this-> = $gender;<br>}</p>
        <p>メソッド内で自分のクラスのメンバ変数を扱うときは $this ポインタをつけてアクセスする</p>
        <h3>オブジェクト（インスタンス）の作成方法</h3>
        <p>例</p>
        <p>$Masa_T = new Human("Masanori Takiguchi", 175, "male");</p>
        <p>インスタンス生成時にコンストラクタの引数を与る</p>
        <p>別のオブジェクトの作成例</p>
        <p>$Taro_T = new Human("Taro Tanaka", 180, "male");</p>
        <p>同じクラスをもとに別の特徴と同じ機能を持ったモノ(オブジェクト)の生成ができる</p>
        <h3>メンバ変数(プロパティ)を外部から参照したい場合</h3>
        <p>public function get_height(){ return $this->height; }<br>public function get_name(){ return $this->name; }</p>
        <p>ゲッターというメソッドを定義することで外部からのプロパティの閲覧のみを可能にする</p>
        <h1>オブジェクトの3大要素</h1>
        <ul>
            <li>カプセル化</li>
            <li>継承</li>
            <li>ポリモーフィズム</li>
        </ul>
        <h2>カプセル化</h2>
        <p>オブジェクトの情報を隠蔽することによって、不整合を引き起こすような操作をできなくさせる仕組み</p>
        <p>カプセル化とは、オブジェクトやデータをカプセルのように保護するという意味から来ている</p>
        <p>クラスで定義されたものは出来るだけ壊されないようにする必要があるので、重要なプロパティは private を付与して外部から中身が不意に書き換えられないようにする</p>
        <h2>継承</h2>
        <p>継承とは、すでに用意されているクラスを他のクラスを作成する時に活用する仕組みで、クラスを作成する時に同じことを何度もプログラミングしなくて良いように「継承」の仕組みが用意されているので似たようなクラスを作成する際に、「継承」を利用すれば記述が簡略化できるの</p>
        <h3>書き方</h3>
        <p>class (新クラス) extends (元クラス) { (新クラスに追加したい内容) }</p>
        <p>既に作成してあった(元クラス)を利用して、それを継承した(新クラス)を作成する</p>
        <p>(元クラス)となる部分に基本的な要素を詰め込んでおいて、それを継承して(新クラス)を作成すると、少しの変更だけで新しいクラスを作成できる</p>
        <p>このとき private がついているものは継承されず、新クラスからもアクセスできないのでプロパティも継承したければ代わりに protected をかく</p>
        <p>注意: (元クラス)の全てを継承して(新クラス)が作成されるとは限らなくこれは、アクセス修飾子がどのように定義されているかに左右される</p>
        <h3>アクセス修飾子の種類</h3>
        <ul>
            <li>public：継承可能。アクセス修飾子の定義が無い場合にはpublic扱い</li>
            <li>private：継承不可能</li>
            <li>protected：継承可能。privateとpublicの中間的存在であり、継承したクラスからは参照できる非公開な要素</li>
        </ul>
        <h2>ポリモーフィズム</h2>
        <p>同じ行動をするものの、その後の動作が異なるという仕組みのことをポリモーフィズムと呼ぶ<br>同じメソッドを複数のクラスで利用してその動作が異なることをポリモーフィズムと呼ぶ</p>
        <p>メソッドをいずれのクラスにも実装し、それぞれ別の定義をするために interface を使う</p>
        <p>各クラスに implements を用いて、明示的にインターフェイスメソッドが実装されることを定義する</p>
        <h2>interface</h2>
        <p>クラスと同じようにインスタンスを作るために定義するもの</p>
        <h3>クラスとは異なる点</h3>
        <ul>
            <li>interfaceからインスタンスの作成はできない</li>
            <li>アクセス修飾子はpublicしか利用できない</li>
            <li>抽象メソッドしか定義できない</li>
        </ul>
        <p>大きな特徴は、直接インスタンスの生成ができないこと</p>
        <p>インスタンスを作成できないため、interfaceで定義されているものからclassで定義されているものに継承しなければならないが、こうすることでこのインターフェイスを継承したクラスは最低でも、ここで定義したメソッドを持つことを明示的に表すことができる</p>
        <h2>implements</h2>
        <p>interfaceからclassへ継承する場合には、継承ではなく実装と呼ばれる違う動作をする</p>
        <h3>ポリモーフィズムを利用することのメリット</h3>
        <ul>
            <li>複雑な処理であっても、ポリモーフィズムを利用することで端的に記述できる</li>
            <li>プログラムの保守性という面でメリットが大きい</li>
            <li>クラスを細分化できる</li>
        </ul>
        <p>ポリモーフィズムを利用することでPHPの記述内容がシンプルになりやすくなり、またクラスの細分化については、クラスの絶対数は多くなる傾向にある<br>でも、細分化されていることで他に与える影響が少なくなったり、保守性が上がるので、メリットのほうが大きい</p>
    </body>
</html>